<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>5.5.&nbsp;Defining Domain-Specific Actions (DSA)</title><link rel="stylesheet" href="css/docbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="Tutorial_Automata.html" title="GEMOC xDSML definition tutorial with Automaton DSML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Increment 1 : Deterministic Automata"><link rel="prev" href="ch05s04.html" title="5.4.&nbsp;Identifying DSE"><link rel="next" href="ch05s06.html" title="5.6.&nbsp;Model of Concurrency and Communication (MoCC)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.5.&nbsp;Defining Domain-Specific Actions (DSA)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Increment 1 : Deterministic Automata</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s06.html">Next</a></td></tr></table><hr></div><div class="section" title="5.5.&nbsp;Defining Domain-Specific Actions (DSA)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_defining_domain_specific_actions_dsa"></a>5.5.&nbsp;Defining Domain-Specific Actions (DSA)</h2></div></div></div><p>DSA includes the definition of Execution Data (ED) and Execution
Functions (EF).  They are both implemented in Kermeta 3 in 'K3 Aspect
project' whose lastname is, by convention, 'k3dsa'.</p><div class="informalexample"><p>Click on <span class="emphasis"><em>K3 project</em></span> in the xDSML view (Behavioral definition / DSA
definition).  The wizard to create of new Kermeta 3 project is
launched with the name of the project initialized (k3dsa is the last
name).</p><p>Default options can be kept except for the value of <span class="emphasis"><em>Use a template
based on ecore file</em></span> field which must be changed from <span class="emphasis"><em>None</em></span> to
<span class="emphasis"><em>Aspect class from ecore file</em></span>.</p><p>We can now finish the wizard.</p><p>Clicking again on <span class="emphasis"><em>K3 project</em></span> will now allow to choose and open
automata.xtend.  It has been initialized with a template that can be
discarded.</p></div><p>We can now complete the Kermeta 3 file (automata.xtend) with the
definition of ED and EF.</p><div class="section" title="5.5.1.&nbsp;Execution Data (ED)"><div class="titlepage"><div><div><h3 class="title"><a name="_execution_data_ed"></a>5.5.1.&nbsp;Execution Data (ED)</h3></div></div></div><p>We identify two runtime information for Automata.  The first one
stores the current state of the automaton. It is called
'currentState', a reference to State.  Its value is either the one of
the state of the automaton or the 'null' value.  The 'null' value
indicates that a symbol has not been accepted by the automaton.</p><p>The second ED stores the status of the symbols being analysed,
either accepted or rejected.  It is modelled as the 'accepted'
boolean.</p><p>TODO: Define a new class in DSA ErrorState which extends
State?  When in the error state, the automate rejects every symbols.</p><div class="informalexample"><p>To add 'currentState' and 'accepted' execution data, we define them in
an Aspect on the Automata class as follow.</p><pre class="programlisting"><b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color: darkred">@Aspect(className=Automata)</b>
<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">class</b> AutomataAspect {
	<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">public</b> State currentState
	<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">public</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">boolean</b> accepted
}</pre></div><div xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p xmlns="">If you plan to use the Graphical animation, then comment the
code above and add this reference to the Ecore Metamodel directly.
This is due to how the animator connects to the Abstract Syntax (for
now).</p></div></div><div class="section" title="5.5.2.&nbsp;Execution Functions (EFs)"><div class="titlepage"><div><div><h3 class="title"><a name="_execution_functions_efs"></a>5.5.2.&nbsp;Execution Functions (EFs)</h3></div></div></div><p>Here are the execution functions we decide to define. The three first
functions corresponds to the DSE already identified, the other ones
are Helpers which ease the writing of the code of the previous ones.
For each of this operation a logging is done.</p><div class="variablelist"><dl><dt><span class="term">Automata.initialize()</span></dt><dd>initialize the automaton:  set its current state to its initial
state and accepted to true.</dd><dt><span class="term">Automata.terminate()</span></dt><dd>decide whether the sequence of symbols has been accepted or
rejected by the automaton.</dd><dt><span class="term">Symbol.occur()</span></dt><dd>makes the automaton read a new occurrence of this symbol.  It is
the main execution functions. It relies on the following helper
functions.</dd><dt><span class="term">State.getTransitions(Symbol s)</span></dt><dd>returns the list of all the outgoing transitions of this
state which accept the s symbol.
It is a <span class="strong"><strong>Query</strong></span> execution function.</dd><dt><span class="term">Automata.read(Symbol s)</span></dt><dd>This automaton reads the symbol s.  It updates the current state
according to the possible outgoing transitions of the current
state and the symbol s.  If there is only one possible transition,
its target state becomes the new current state (delegated to
Transition.fire() helper).  If there is several possible
transitions, then the automaton is Nondeterministic and an
exception is raised.  Finally, is there is no possible transition,
the current state becomes an error ('currentSate' is set to
'null') the state and the sequence of symbols will be rejected.
If the automaton was already in an error state, then nothing
happens.</dd><dt><span class="term">Transition.fire()</span></dt><dd>change the current state of the
automata: the new state is target state of this transition.
A precondition checks that the source state of the transition is the
current state of the automata.  An exception is thrown if the
precondition fails.</dd></dl></div><p>Here is the complete 'automata.xtend' file with the code of all
execution functions (and execution data).</p><p title="automata.xtend"><b>automata.xtend.&nbsp;</b>
</p><pre class="screen">package automata

import java.util.logging.Level
import java.util.logging.Logger

import static extension automata.AutomataAspect.*
import static extension automata.SymbolAspect.*
import static extension automata.StateAspect.*
import static extension automata.AutomataAspect.*
import static extension automata.TransitionAspect.*

import fr.inria.diverse.k3.al.annotationprocessor.Aspect

@Aspect(className=Automata)
class AutomataAspect {
	static private Logger logger = Logger.getLogger(typeof(Automata).getName())

	public State currentState
	public boolean accepted

	def public void initialize() {
		_self.currentState = _self.initialState;
		_self.accepted = false;
		_self.logger.info("[" + _self.name + "] Initialized, currentState is " + _self.currentState.name + ".")
	}

	def public void terminate() {
		_self.logger.info("[" + _self.name + "]" + "Finished.")
		// XXX: ne marche pas
		_self.accepted = _self.currentState != null &amp;&amp; _self.currentState.isFinal
		val cs = _self.states.filter[ it === _self.currentState ]
		_self.accepted = cs.size &gt; 0 &amp;&amp; cs.head.isFinal
		var result = "rejected"	// XXX better way to write it?
		if (_self.accepted) {
			result = "accepted"
		}
		// throw new RuntimeException("Finished. Word is " + result)
			// throwing an exception is the only way for the moment to
			// force the simulation to end.
	}

	//@ Helper with arguments
	def void read(Symbol s) {
		_self.logger.info("[" + _self.name + "]" + "read(" + s.name + ").")
		if (_self.currentState == null) {
			_self.logger.finer("** Already in the error state!");
		} else {
			val possibleTransitions = _self.currentState.getTransitions(s)
			val size = possibleTransitions.size
			// FIXME: I have not been able to write it with a switch :(
			if (size == 0) {	// No possible transition
				_self.logger.finer("No transition for symbol " + s.name + " from state " + _self.currentState.name)
				_self.currentState = null
				_self.accepted = false	// useful?
			} else if (size == 1) {	// only one possible transition
				var singleTransition = possibleTransitions.head
				_self.logger.finer("Only one possible transition: " + singleTransition.name)
				singleTransition.fire()
			} else {	// nondeterministic
				throw new RuntimeException("Non deterministic automaton: "
						+ "several transitions accept symbol " + s.name
						+ " in state " + _self.currentState.name)
			}
		}
	}

	def String toString() {
		// XXX To be improved
		var String str = "States : "
		str += _self.states.map[ s | (if (s == _self.currentState)  '[' + s.name + ']' else s.name)
			+ (if (s.isFinal) '!' else '')]
		str
	}

}


@Aspect(className=State)
class StateAspect {

	//@ Helper (Query) with arguments
	def package Iterable&lt;Transition&gt; getTransitions(Symbol s){
		_self.outgoingTransitions.filter[symbols.filter[name == s.name].size &gt; 0]
	}

}


@Aspect(className=Symbol)
class SymbolAspect {
	static private Logger logger = Logger.getLogger(typeof(Symbol).getName())

	def public void occur() {
		_self.logger.info("[" + _self.automata.name + "]" + "Symbol " + _self.name + " occurred.")
		_self.automata.read(_self)	// call an helper DSA
	}

}


@Aspect(className=Transition)
class TransitionAspect {
	static private Logger logger = Logger.getLogger(typeof(Transition).getName())

	def package void fire() {
		Contract.require(_self.automata.currentState === _self.source,
				"[" + _self.automata.name + "]" + "Source state of " + _self.name
				+ " (" + _self.source.name + ") is not the current state (" + _self.automata.currentState.name + ")")
		_self.logger.info("[" + _self.automata.name + "]" + "Fired Transition " + _self.name + ".")
		_self.automata.currentState = _self.target
	}

}</pre><p title="automata.xtend">
</p></div><div class="section" title="5.5.3.&nbsp;Testing DSA"><div class="titlepage"><div><div><h3 class="title"><a name="_testing_dsa"></a>5.5.3.&nbsp;Testing DSA</h3></div></div></div><p>Once the DSA are written --- or, even better, while they are written
--- we must test them.</p><p>First, we define a method that feeds an automaton with a word (each
letter of the word is considered as a symbol).  It is defined in the
AutomataExecution class.  Here is the xtend code.</p><pre class="programlisting"><b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">package</b> automata

<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">static</b> extension automata.AutomataAspect.*
<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">static</b> extension automata.SymbolAspect.*

<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">class</b> AutomataExecution {

	def <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">static</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">boolean</b> accepted(Automata a, String word) {
		println(<i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"==== What about "</i> + word + <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"?"</i>)
		a.initialize()
		<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">for</b> (var i = <span class="hl-number">0</span>; i <b class="hl-tag" style="color: #000096">&lt;</b> <span class="hl-attribute" style="color: #F5844C">word.length();</span> <span class="hl-attribute" style="color: #F5844C">i++)</span> <span class="hl-attribute" style="color: #F5844C">{</span>
			<span class="hl-attribute" style="color: #F5844C">val</span> <span class="hl-attribute" style="color: #F5844C">c</span> = <span class="hl-value" style="color: #993300">word.charAt(i)</span>
			<span class="hl-attribute" style="color: #F5844C">val</span> <span class="hl-attribute" style="color: #F5844C">ss</span> = <span class="hl-value" style="color: #993300">a.symbols.filter[name.equals(</span><i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">""</i> + c)]
			<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">if</b> (ss.size == <span class="hl-number">0</span>) {	<i xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-comment" style="color: darkgreen">// unknown symbol for the automaton</i>
				<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">return</b> false
			} <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">else</b> {
				ss.get(<span class="hl-number">0</span>).occur()
			}
		}
		a.terminate()
		println(<i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"==== What about "</i> + word + <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"? : "</i> + a.accepted)
		a.accepted
	}

}</pre><p>Then, we can write a classical JUnit TestCase that tests an automaton
on some tests using the 'AutomataExecution.accepted(String word)'
method.
Here is an example of such a test case.</p><pre class="programlisting"><b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">package</b> automata;

<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> org.junit.Test;
<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">static</b> org.junit.Assert.*;
<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">static</b> automata.AutomataIO.*;
<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">import</b> org.eclipse.emf.ecore.resource.Resource;

<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">public</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">class</b> AutomataTest {

	<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color: darkred">@Test</b>
	<b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">public</b> <b xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-keyword" style="color:darkblue">void</b> testerAStar() {
		Resource model = loadResource(<i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"../org.example.automata.as/model/aS.xmi"</i>);	<i xmlns:fo="http://www.w3.org/1999/XSL/Format" class="hl-comment" style="color: darkgreen">// XXX</i>
		Automata a = (Automata) model.getContents().get(<span class="hl-number">0</span>);

		assertTrue(AutomataExecution.accepted(a, <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"a"</i>));
		assertTrue(AutomataExecution.accepted(a, <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"aaaaa"</i>));
		assertTrue(AutomataExecution.accepted(a, <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">""</i>));
		assertFalse(AutomataExecution.accepted(a, <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"aaabaaa"</i>));
		assertFalse(AutomataExecution.accepted(a, <i xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color:blue" class="hl-string">"c"</i>));
	}

}</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s04.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.4.&nbsp;Identifying DSE&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="Tutorial_Automata.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.6.&nbsp;Model of Concurrency and Communication (MoCC)</td></tr></table></div></body></html>