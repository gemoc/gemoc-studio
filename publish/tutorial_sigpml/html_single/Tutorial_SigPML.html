<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SigPML overview</title><link rel="stylesheet" href="css/docbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="SigPML overview"><div class="titlepage"><div><div><h1 class="title"><a name="d0e3"></a>SigPML overview</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#_sigpml_overview">1. SigPML overview</a></span></dt><dt><span class="chapter"><a href="#_import_and_install_the_projects_for_the_abstract_and_concrete_syntax">2. Import and install the projects for the abstract and concrete syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#_sigpml_abstract_syntax">2.1. SigPML abstract syntax</a></span></dt><dt><span class="section"><a href="#_sigpml_concrete_syntax_and_sample_model">2.2. SigPML concrete syntax and sample model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_creating_an_xdsml_project">3. Creating an xDSML Project</a></span></dt><dd><dl><dt><span class="section"><a href="#_open_xdsml_view">3.1. Open xDSML view</a></span></dt><dt><span class="section"><a href="#_select_the_domain_model">3.2. Select the domain model</a></span></dt><dt><span class="section"><a href="#_select_the_graphical_editor">3.3. Select the graphical editor</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_sigpml_execution_semantics">4. SigPML execution semantics</a></span></dt><dd><dl><dt><span class="section"><a href="#_execution_semantics_overview">4.1. Execution semantics overview</a></span></dt><dt><span class="section"><a href="#_dsa_definition">4.2. DSA definition</a></span></dt><dd><dl><dt><span class="section"><a href="#_extending_the_ecore_definition">4.2.1. Extending the Ecore definition</a></span></dt><dt><span class="section"><a href="#_creating_the_dsa_project">4.2.2. Creating the DSA project</a></span></dt><dt><span class="section"><a href="#_implementation_of_the_dsa">4.2.3. Implementation of the DSA</a></span></dt></dl></dd><dt><span class="section"><a href="#_dse_definition">4.3. DSE definition</a></span></dt><dd><dl><dt><span class="section"><a href="#_creating_the_ecl_project">4.3.1. Creating the ECL project</a></span></dt><dt><span class="section"><a href="#_implementation_of_the_ecl">4.3.2. Implementation of the ECL</a></span></dt></dl></dd><dt><span class="section"><a href="#_moccml_definition">4.4. MoCCML definition</a></span></dt><dd><dl><dt><span class="section"><a href="#_creating_the_moccml_project">4.4.1. Creating the MoCCML project</a></span></dt><dt><span class="section"><a href="#_implementation_of_the_moccml">4.4.2. Implementation of the MoCCML</a></span></dt></dl></dd><dt><span class="section"><a href="#_create_an_animator">4.5. Create an animator</a></span></dt><dd><dl><dt><span class="section"><a href="#_creating_the_animator_project_as_a_sirius_viewpoint">4.5.1. Creating the Animator project as a Sirius viewpoint</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_sigpml_modeling_workbench">5. SigPML modeling workbench</a></span></dt><dd><dl><dt><span class="section"><a href="#_launch_the_modeling_workbench_creation_start_a_new_eclipse">5.1. Launch the Modeling workbench creation (Start a new Eclipse)</a></span></dt><dt><span class="section"><a href="#_import_the_project_with_a_sample_model">5.2. Import the project with a sample model</a></span></dt><dt><span class="section"><a href="#_create_a_debug_launch_configuration">5.3. Create a debug launch configuration</a></span></dt><dt><span class="section"><a href="#_start_the_model">5.4. Start the model</a></span></dt><dt><span class="section"><a href="#_select_a_logical_step">5.5. Select a logical step</a></span></dt><dt><span class="section"><a href="#_select_a_logical_step_in_the_past">5.6. Select a logical step in the past</a></span></dt><dt><span class="section"><a href="#_stop_the_animation">5.7. Stop the animation</a></span></dt><dt><span class="section"><a href="#_this_is_the_end">5.8. This is the end</a></span></dt></dl></dd></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;SigPML overview"><div class="titlepage"><div><div><h2 class="title"><a name="_sigpml_overview"></a>Chapter&nbsp;1.&nbsp;SigPML overview</h2></div></div></div><p>SigPML is a Domain Specific Modeling Language dedicated to data flow processing.
The concrete syntax is based on blocks, ports and connectors which associated ports to create directed flows.
The DSML execution semantics defines that all the blocks of a model run concurrently regarding constraints on connector synchronization.
The tutorial includes two execution semantics with the first one which defines a synchronization of the block execution with the pop and push actions of the connectors.
The second one introduces read and write operations in the block semantics to decouple the connector acces.</p><p>The final result of the SigPML model execution is showed on the next picture with a purple processing block which is an executing block and the brown block waits for a connector synchronization after its connector acces.</p><p><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/OverviewExecuteSigpmlModelWithVCD.png" alt="Execution of a SigPML model"></span></p></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Import and install the projects for the abstract and concrete syntax"><div class="titlepage"><div><div><h2 class="title"><a name="_import_and_install_the_projects_for_the_abstract_and_concrete_syntax"></a>Chapter&nbsp;2.&nbsp;Import and install the projects for the abstract and concrete syntax</h2></div></div></div><div class="section" title="2.1.&nbsp;SigPML abstract syntax"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_sigpml_abstract_syntax"></a>2.1.&nbsp;SigPML abstract syntax</h2></div></div></div><p>This language is based on the Ecore metamodel presented in the next figure.</p><p><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/sigpmldomainEcore.png" alt="SigPML metamodel"></span></p><p>A SigPML Application is a set of Blocks and a set of Connectors which in relation with the blocks through input and output ports.
The Connector concept owns the capacity attribute which defines the maximum number of access on the connector, and the currentSize attribute provides the current acces number on the connector.
The Port contains the rate attribute which defines the possible access number input and output ports.</p></div><div class="section" title="2.2.&nbsp;SigPML concrete syntax and sample model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_sigpml_concrete_syntax_and_sample_model"></a>2.2.&nbsp;SigPML concrete syntax and sample model</h2></div></div></div><p>The graphical concrete syntax is defined with the Sirius component. We provide a Sirius project as a zip file.
You can also make your own Sirius project and use the online <a class="link" href="https://wiki.eclipse.org/Sirius/Tutorials/4MinTutorial#Overview" target="_top">Sirius tutorial</a> and the online <a class="link" href="http://www.eclipse.org/sirius/doc/" target="_top">Sirius Documentation</a>.</p><p>With the provided project, the final result of the modeling tool is showed in the next figure.</p><p title="SigPML final animation modeling tool"><b>SigPML final animation modeling tool.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/sigpmlModelEditor.png" alt="SigPML modeling tool"></span></p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Creating an xDSML Project"><div class="titlepage"><div><div><h2 class="title"><a name="_creating_an_xdsml_project"></a>Chapter&nbsp;3.&nbsp;Creating an xDSML Project</h2></div></div></div><p>First, start by creating a new xDSML project (<span class="emphasis"><em>New &gt; Project &gt; GEMOC
Project / new xDSML Project</em></span>), with your desired name, for instance
"org.gemoc.sample.xsigpml".  In the created project, we can open the
project.xdsml file. The xDSML view summarizes all the important
resources used in an xDSML project (which are part of and managed by
other projects).  This view is the top level definition of a xDSML to
have an access to any other projects include in the definition of our xDSML.</p><div class="section" title="3.1.&nbsp;Open xDSML view"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_open_xdsml_view"></a>3.1.&nbsp;Open xDSML view</h2></div></div></div><p>A xDSML project definition includes the Domain model definition of our DSML as a classical ecore model, the concrete syntax definition and the behavior definition.
The concrete syntax can be textual (based on xtext project)  or graphical (Sirius project). The graphical animation viewpoint is an extension of the graphical textaul syntax (Sirius project).
The behavior definition is based on an aspect definition of the DSML domain model for the Domain Specific Action (DSA) as a Kermeta3 project ; and the MoCC defines the concurent semantics of the DSML as a MoCCML project and finaly the definition of the mapping between the DSA and MoCC definitions as the Domain Specific Event (DSE) with a ECL project.</p><p>Each of these definitions are based on existing and dedicated projects.</p><p title="xDSML wizard definition"><b>xDSML wizard definition.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/xDSMLProjectWindow.jpg" alt="xDSML wizard with all the constituents"></span></p></div><div class="section" title="3.2.&nbsp;Select the domain model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_select_the_domain_model"></a>3.2.&nbsp;Select the domain model</h2></div></div></div><p>You can select an existing domain model to reference the Ecore model as the DSML abstract syntax.
You must specify the root element of you domain model.</p><p title="Domain model selection"><a name="img-domainModelSelect"></a><b>Domain model selection.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/selectDomainModel.jpg" alt="Domain model selection"></span></p><p>Or you can create an Ecore project with the provided <a class="link" href="tutorialfiles/quickTutorial/sigpml/sigpmldomain.ecore" target="_top">Ecore file</a>.</p></div><div class="section" title="3.3.&nbsp;Select the graphical editor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_select_the_graphical_editor"></a>3.3.&nbsp;Select the graphical editor</h2></div></div></div><p>You can select an existing graphical editor model to reference the Sirius project as the graphical  syntax of your DSML.</p><p title="Sirius Graphical model selection"><b>Sirius Graphical model selection.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/selectGraphicalEditor.jpg" alt="Sirius Graphical model selection"></span></p><p>Or you can create a Sirius project with the provided <a class="link" href="tutorialfiles/quickTutorial/sigpml/sigpmlTuto.odesign" target="_top">The odesign file</a>.</p></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;SigPML execution semantics"><div class="titlepage"><div><div><h2 class="title"><a name="_sigpml_execution_semantics"></a>Chapter&nbsp;4.&nbsp;SigPML execution semantics</h2></div></div></div><div class="section" title="4.1.&nbsp;Execution semantics overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_execution_semantics_overview"></a>4.1.&nbsp;Execution semantics overview</h2></div></div></div><p>The execution semantics of the DSML must define that all the model blocks run concurrently.
The block execution is constrained by the access on the connectors associated with the the block through input and output ports.
So an execute function of the blocks is synchronized on the connector functions, pop (from the connector connected through the input port on the block) and push (from the connector connected through the output port on the block).
A connector has a capacity defining the maximum number of available operations (pop and push). Virtually, pop reads data from the connector and push writes data in the connector.
The rate to read and write in the connector is defined as an attribute of the ports.</p><p>So we must define:
- the Execution Data (ED) and Execution Function (EF) into the DSA definition
- the MoCC with a MoCCML model
- the mapping between the MoCC and the DSA (ED and EF)</p></div><div class="section" title="4.2.&nbsp;DSA definition"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_dsa_definition"></a>4.2.&nbsp;DSA definition</h2></div></div></div><p>The DSA definition includes two steps :
- adding Execution Data and Execution Function in the Ecore model.
- creating aspects to weave with the Ecore model in Kermeta3</p><div class="section" title="4.2.1.&nbsp;Extending the Ecore definition"><div class="titlepage"><div><div><h3 class="title"><a name="_extending_the_ecore_definition"></a>4.2.1.&nbsp;Extending the Ecore definition</h3></div></div></div><p>So first, Execution Data and Execution Function definitions are added to the domain model of SigPMLTuto ecore file. We extend the SigPML metamodel by adding one function <span class="emphasis"><em>execute()</em></span> in the <span class="emphasis"><em>Block</em></span> class and the functions <span class="emphasis"><em>push()</em></span> and <span class="emphasis"><em>pop()</em></span> in <span class="emphasis"><em>Connector</em></span> class. These functions are added with the Ecore reflexive editor.</p><p title="Execution Function in the SigPML metamodel"><b>Execution Function in the SigPML metamodel.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/EF_InEcoreDomainModel.png" alt="Execution Function in the SigPML metamodel"></span></p></div><div class="section" title="4.2.2.&nbsp;Creating the DSA project"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_the_dsa_project"></a>4.2.2.&nbsp;Creating the DSA project</h3></div></div></div><p>The creation of the DSA project is New&#8594;Other&#8594;Kermeta3&#8594;K3 project&#8594;give the name&#8594;next&#8594;select "Create a plugin using one the templates"&#8594;choose "User Ecore Basic Aspects"&#8594;fill in allthe requested names and select the Ecore domain model.</p><p>The resulted DSA project is a k3dsa project with a sigpmlAspects.xtend file in the package <span class="emphasis"><em>org.gemoc.sample.xsigpml.k3dsa</em></span>.
This file contains the aspects that we want to add to the necessary classes in our case <span class="emphasis"><em>Block</em></span> and <span class="emphasis"><em>Connector</em></span>.</p><p><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/resultedDSAProject.png" alt="DSA project and associated aspect file"></span></p></div><div class="section" title="4.2.3.&nbsp;Implementation of the DSA"><div class="titlepage"><div><div><h3 class="title"><a name="_implementation_of_the_dsa"></a>4.2.3.&nbsp;Implementation of the DSA</h3></div></div></div><p>In this tutorial, the implementation of the functions is simple. The <span class="emphasis"><em>execute</em></span> function increments the <span class="emphasis"><em>currentExecCycle</em></span> of a block until its value is inferior to the <span class="emphasis"><em>cycles</em></span> value.</p><p>The source code is available through
<a class="link" href="tutorialFiles/quickTutorial/sigpml/sigpmlAspects.xtend" target="_top">Kermeta 3 aspects,tabsize=4</a>
and showed below</p><pre class="screen">package org.gemoc.sample.xsigpml.k3dsa



import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import sigpml.Application
import sigpml.Block
import sigpml.Port
import sigpml.InputPort
import sigpml.OutputPort
import sigpml.Connector
import sigpml.NamedElement



@Aspect(className=Application)
class ApplicationAspect extends org.gemoc.sample.xsigpml.k3dsa.NamedElementAspect {


}


@Aspect(className=Block)
class BlockAspect extends org.gemoc.sample.xsigpml.k3dsa.NamedElementAspect {

	public int currentExecCycle = 0


	def public void execute() {

		if ( _self.currentExecCycle &lt; _self.cycles )
			_self.currentExecCycle = _self.currentExecCycle + 1
		else
			_self.currentExecCycle = 0

		println(_self.name + "\n      execute (" + _self.currentExecCycle + ")" )

	}

}


@Aspect(className=Connector)
class ConnectorAspect extends org.gemoc.sample.xsigpml.k3dsa.NamedElementAspect {


	def public void push() {

		println( " Push on : " + _self.name + "\n ")
	}

	def public void pop() {

		println( " Pop on : " + _self.name + "\n ")
	}

}


@Aspect(className=NamedElement)
abstract class NamedElementAspect {

}</pre></div></div><div class="section" title="4.3.&nbsp;DSE definition"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_dse_definition"></a>4.3.&nbsp;DSE definition</h2></div></div></div><p>The DSE definition is related to declare the Domain Specific Events which define the event interface of our language.</p><p>The two next sections ECL and MoCC definitions are tightly coupled. So you can create the two projects and iterate between the two projects in progress.</p><div class="section" title="4.3.1.&nbsp;Creating the ECL project"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_the_ecl_project"></a>4.3.1.&nbsp;Creating the ECL project</h3></div></div></div><p>From the xDSML project, we select the associated wizard of the DSE definition that helps to create an ECL project (Event Constraint Language). After you give a name on your project&#8594;next&#8594;(you must have a reference on your Ecore domain file)&#8594;finish</p><p title="ECL project creation"><b>ECL project creation.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/createECLProject.png" alt="ECL project creation"></span></p></div><div class="section" title="4.3.2.&nbsp;Implementation of the ECL"><div class="titlepage"><div><div><h3 class="title"><a name="_implementation_of_the_ecl"></a>4.3.2.&nbsp;Implementation of the ECL</h3></div></div></div><p>An ECL program defines the mapping between the domain model, including ED and EF, and the MoCC definition of the next section.
In this program, you declare the metaclasses that you want to select ED or EF, and associating them with a MoCC definition.</p><p>A metaclass is referenced as <span class="emphasis"><em>Context</em></span> and in this scope we define an event relative to the EF and also invariants that must be satisfied in the context of the metaclasse.</p><p>In this tutorial, two contexts are declared for the metaclasses <span class="emphasis"><em>Block</em></span> and <span class="emphasis"><em>Connector</em></span>.
In the context of <span class="emphasis"><em>Block</em></span> an event <span class="emphasis"><em>execute</em></span> is defined relative to the execution function of the same name in the <span class="emphasis"><em>Block</em></span> metaclasse.
In the context of <span class="emphasis"><em>Connector</em></span>, an invariant is declared based on the call of a relation declaration. The arguments of this relation are associated to the attributes of the metaclasses <span class="emphasis"><em>Connector</em></span> and also we can access by navigation expression to the others <span class="emphasis"><em>Ports</em></span> (for the <span class="emphasis"><em>rate</em></span> attribute) and <span class="emphasis"><em>Block</em></span> (for the execute EF).</p><p>This relation is defined in the MoCCML program of the next section.</p><p>The source code is available through
<a class="link" href="tutorialfiles/quickTutorial/sigpml/xSigpml.ecl" target="_top">the ECL program</a>
and showed below</p><pre class="screen">import 'platform:/resource/org.gemoc.sigpmldomain/model/sigpmldomain.ecore'
--import './sigpmldomain.ecore'

ECLimport "platform:/resource/org.gemoc.sample.xSigpml.mocc/mocc/xSigpml.moccml"
--ECLimport "./xSigpml.moccml"
ECLimport "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib"
ECLimport "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib"


package sigpml

	context Block
		def : execute : Event = self.execute()


	context Connector
		inv ConnectorComputing:
			let capacity : Integer = self.oclAsType(Connector).capacity in
		 	let inRate : Integer = self.itsInputPort.oclAsType(Port).rate in
		 	let outRate : Integer = self.itsOutputPort.oclAsType(Port).rate in
		 	let currentSize : Integer = self.oclAsType(Connector).currentSize in

		 Relation ConnectorSDF_PAM (
				self.itsOutputPort.oclAsType(OutputPort).owner.oclAsType(Block).execute,
				self.itsInputPort.oclAsType(InputPort).owner.oclAsType(Block).execute,
				capacity,
				inRate,
				outRate,
				currentSize
			)


endpackage</pre></div></div><div class="section" title="4.4.&nbsp;MoCCML definition"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_moccml_definition"></a>4.4.&nbsp;MoCCML definition</h2></div></div></div><div class="section" title="4.4.1.&nbsp;Creating the MoCCML project"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_the_moccml_project"></a>4.4.1.&nbsp;Creating the MoCCML project</h3></div></div></div><p>From the xDSML project, we select the associated wizard of the MoCC definition that helps to create the moCCML project. Fill the name of the project&#8594;next&#8594;fill the name of the file&#8594;finish</p><p title="MoCCML project creation"><b>MoCCML project creation.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/MoCCProjectCreation.png" alt="MoCCML project creation"></span></p><p>In the resulting project, we have a directory <span class="emphasis"><em>mocc</em></span> with the <span class="emphasis"><em>MoCCML</em></span> file.</p></div><div class="section" title="4.4.2.&nbsp;Implementation of the MoCCML"><div class="titlepage"><div><div><h3 class="title"><a name="_implementation_of_the_moccml"></a>4.4.2.&nbsp;Implementation of the MoCCML</h3></div></div></div><p>In the MoCCML program, we define the constraint relation referenced in the ECL program (in our case, the <span class="emphasis"><em>ConnectorSDF_PAM</em></span> relation). This relation is based on an automaton definition.</p><p>This automaton describes how the events and variables are used to define a constraint automaton relative to each instance of the <span class="emphasis"><em>Connector</em></span> class.</p><p>The source code is available through
<a class="link" href="tutorialfiles/quickTutorial/sigpml/xSigpml.moccml" target="_top">the MoCCML program</a>
and showed below</p><pre class="screen">AutomataConstraintLibrary xSigpmlMocc{

		import "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib" as kernel;
		import "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib" as ccsl;


	RelationLibrary BlockFlowRelationDefLib {



		AutomataRelationDefinition ConnectorSDF_PAM_Def [ ConnectorSDF_PAM ] {

			variables {
				Integer capacity=0
				Integer size=0
				Integer un=1
				Integer deux = 2
				Integer inRate=0
				Integer outRate=0
			 }

			init:  CES0

			from CES0 to CES1 : CES0ToCES1
			-&gt;(
				do size = Connector_currentSize.value
				do capacity = Connector_capacity.value
				do inRate = Connector_inRate.value
				do outRate = Connector_outRate.value
			)


			from CES1 to CES1 : PUSHCES1ToCES1
			-&gt; (
				when ConnectorSDF_PAM_pop if( size &gt;= inRate ) do size = ( size - inRate )
			)

			from CES1 to CES1 : POPCES1ToCES11
			-&gt; (
				when ConnectorSDF_PAM_push if( (size + outRate ) &lt;= capacity ) do size = ( size + outRate )
			)


			State CES0
			(
			  out : CES0ToCES1
			)

			State CES1
			( in : CES0ToCES1, PUSHCES1ToCES1, POPCES1ToCES11
			  out : POPCES1ToCES11, PUSHCES1ToCES1
			)


		}


		RelationDeclaration ConnectorSDF_PAM(
			ConnectorSDF_PAM_push:clock,
			ConnectorSDF_PAM_pop:clock,
			Connector_capacity:int,
			Connector_inRate:int,
			Connector_outRate:int,
			Connector_currentSize:int
		)





	}

}</pre><p>At the end of this step the SigPML language is completely in terms of the metamodel, the graphical syntax, the behavior code of the functions, the expression of the concurrent semantics and the mapping them.</p><p>The last step is to define the animation view of the models as a debug extension of the graphical syntax.</p></div></div><div class="section" title="4.5.&nbsp;Create an animator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_create_an_animator"></a>4.5.&nbsp;Create an animator</h2></div></div></div><div class="section" title="4.5.1.&nbsp;Creating the Animator project as a Sirius viewpoint"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_the_animator_project_as_a_sirius_viewpoint"></a>4.5.1.&nbsp;Creating the Animator project as a Sirius viewpoint</h3></div></div></div><p>As the section dedicated to the graphical syntax, the animator is defined as a Sirius viewpoint based on
<a class="link" href="tutorialfiles/quickTutorial/sigpml/xSigpmlAnim.odesign" target="_top">the odesign file</a></p><p>In this file, we define the viewpoint as an extension of the <span class="emphasis"><em>odesign</em></span> file of the graphical syntax and modify the graphical shape of the blocks when the <span class="emphasis"><em>currentExecCycle</em></span> variable is incremented. The expression <span class="emphasis"><em>[ self.eGet('currentExecCycle') &gt; 0 /]</em></span> is declared to customize the graphical shape of the blocks.</p><p>We create an animation project through the xDSML definition.</p><p title="Animation project creation"><b>Animation project creation.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/AnimationProjectCreation.png" alt="Animation project creation"></span></p><p>We select the <span class="emphasis"><em>Add a debug layer to an existing diagram description</em></span>&#8594;next&#8594;select the SigPMLAppliDiagram&#8594;next&#8594;select the name of the Debug layer&#8594;finish.
We can replace the <span class="emphasis"><em>odesign</em></span> file by the provided one.</p><p>For now the language is totatly defined and executable, so we can used the SigPML Language !!</p></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;SigPML modeling workbench"><div class="titlepage"><div><div><h2 class="title"><a name="_sigpml_modeling_workbench"></a>Chapter&nbsp;5.&nbsp;SigPML modeling workbench</h2></div></div></div><p>From the language workbench, the Sigpml modeling workbench can be used to create a model and execute it.</p><div class="section" title="5.1.&nbsp;Launch the Modeling workbench creation (Start a new Eclipse)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_launch_the_modeling_workbench_creation_start_a_new_eclipse"></a>5.1.&nbsp;Launch the Modeling workbench creation (Start a new Eclipse)</h2></div></div></div><p>To launch the modeling workbench dedicated to the Sigpml language, we create an eclipse apllication configuration to run the gemocstudio associated with the xDSML definition.
The current parameters are set conforming to the parameters of the next picture.</p><p title="Modeling Workbench launching"><b>Modeling Workbench launching.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/CreateModelingWorkbench.png" alt="Modeling Workbench launching"></span></p><p>To obtain modeling workbench adequate performances, we set the VM parameters in the <span class="emphasis"><em>Arguments</em></span> tab to</p><pre class="screen">-Xmx3000m
-Xms3000m</pre></div><div class="section" title="5.2.&nbsp;Import the project with a sample model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_import_the_project_with_a_sample_model"></a>5.2.&nbsp;Import the project with a sample model</h2></div></div></div><p>First you create a sigpml model or you can install the given model in an eclipse project
<a class="link" href="tutorialfiles/quickTutorial/sigpml/SigpmlModelingTuto.zip" target="_top">The modeling project</a>.</p></div><div class="section" title="5.3.&nbsp;Create a debug launch configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_create_a_debug_launch_configuration"></a>5.3.&nbsp;Create a debug launch configuration</h2></div></div></div><p>To execute a model, we create a debug configuration and set the parameters conforming to the picture <a class="xref" href="#debugLaunching" title="The debug launching configuration">The debug launching configuration</a>.</p><p title="The debug launching configuration"><a name="debugLaunching"></a><b>The debug launching configuration.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/DebugLaunchingConfiguration.png" alt="The debug launching configuration"></span></p><p>In this configuration, we select the step by step execution with user selection for the next logical step.</p></div><div class="section" title="5.4.&nbsp;Start the model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_start_the_model"></a>5.4.&nbsp;Start the model</h2></div></div></div><p>When the model is executing, the overview of the modeling workbench is presented in the next picture.</p><p title="The executed Sigpml model"><b>The executed Sigpml model.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/OverviewExecuteSigpmlModel.png" alt="The executed Sigpml model"></span></p><p>The views are extended with the VCD view which presents all the clocks define in the MoccML model with a tick clock during the logical steps.</p><p title="The Sigpml model with a VCD view"><b>The Sigpml model with a VCD view.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/OverviewExecuteSigpmlModelWithVCD.png" alt="The Sigpml model with a VCD view"></span></p><p>The sigpml model is edited in the model editor and we can select model elements and change the model element properties.</p><p title="The Sigpml model element properties"><b>The Sigpml model element properties.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/SigpmlModelProperties.png" alt="The Sigpml model element properties"></span></p></div><div class="section" title="5.5.&nbsp;Select a logical step"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_select_a_logical_step"></a>5.5.&nbsp;Select a logical step</h2></div></div></div><p>To start the execution of the model, we select a logical step to execute the model in the <span class="emphasis"><em>Concurrent Logical Steps Decider</em></span> in the upper right window. The logical step contains the event <span class="emphasis"><em>MSE\_B1\_execute</em></span> so to select this event the Mocml model activates the <span class="emphasis"><em>execute</em></span> function of the Block <span class="emphasis"><em>B1</em></span>. So the animation view of the model is updated due to the expression defines in the animation viewpoint.</p><p title="Start the Sigpml model"><b>Start the Sigpml model.&nbsp;</b><span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/StartExecutionFirstLogicalStep.png" alt="Start the Sigpml model"></span></p><p>After, we select again the logical steps to execute and the model progesses and the exection trace is visualized in the timeline view.
.The Sigpml model trace timeline
<span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/ExecutionTraceTimeline.png" alt="The Sigpml model trace timeline"></span></p></div><div class="section" title="5.6.&nbsp;Select a logical step in the past"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_select_a_logical_step_in_the_past"></a>5.6.&nbsp;Select a logical step in the past</h2></div></div></div><p>We can select a logical step from the past in the timeline, to retstart the execution from this logical step.
In this case, a branch appears in the timeline view and we continue the logical step selection.
.Timeline branches after backwards
<span class="inlinemediaobject"><img src="./images/quickTutorial/sigpml/TimelineBranches.png" alt="Timeline branches after backwards"></span></p></div><div class="section" title="5.7.&nbsp;Stop the animation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_stop_the_animation"></a>5.7.&nbsp;Stop the animation</h2></div></div></div><p>To stop the animation, we select the red button in the <span class="emphasis"><em>Gemoc engines status</em></span> view or in the <span class="emphasis"><em>Concurrent Logical Steps Decider</em></span>.</p></div><div class="section" title="5.8.&nbsp;This is the end"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_this_is_the_end"></a>5.8.&nbsp;This is the end</h2></div></div></div><p>At this step, we have described all the basic possibilities of the Gemoc studio on this tutorial.</p></div></div></div></body></html>