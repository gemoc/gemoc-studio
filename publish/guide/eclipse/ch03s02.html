<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Make a concurrent executable language</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="Guide.html" title="GEMOC Studio User Guide"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Make a language executable"><link rel="prev" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Make a language executable"><link rel="next" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Define an animator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Make a concurrent executable language</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Make a language executable</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch04.html">Next</a></td></tr></table><hr></div><div class="section" title="Make a concurrent executable language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="make-concurrent-language-executable-section"></a>Make a concurrent executable language</h2></div></div></div><div class="section" title="Defining the Domain-Specific Actions (DSA) Project for concurrent language"><div class="titlepage"><div><div><h3 class="title"><a name="section-define-dsa-project"></a>Defining the Domain-Specific Actions (DSA) Project for concurrent language</h3></div></div></div><div class="section" title="Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="_purpose_4"></a>Purpose</h4></div></div></div><p>The Domain-Specific Actions define the runtime state (<span class="strong"><strong>Execution Data</strong></span>) of the model and the operations (<span class="strong"><strong>Execution Functions</strong></span>) which modify the runtime state of the model.</p></div><div class="section" title="Creating the DSA Project"><div class="titlepage"><div><div><h4 class="title"><a name="_creating_the_dsa_project_2"></a>Creating the DSA Project</h4></div></div></div><p>In the GEMOC Studio, the DSA are implemented using <a class="link" href="https://github.com/diverse-project/k3/wiki" target="_top">Kermeta 3</a>.
To create a new DSA Project, in the main menu of the GEMOC Studio, go to: <span class="emphasis"><em>File &gt; New &gt; Project&#8230;&#8203; &gt; K3 Project</em></span>. In the wizard, create it as a Plug-in with EMF using the template of your choice.
Then, connect the xDSML Project to the DSA Project by referencing the DSA Project in the <span class="emphasis"><em>project.xdsml</em></span> file.</p></div><div class="section" title="Editing the DSA Project"><div class="titlepage"><div><div><h4 class="title"><a name="_editing_the_dsa_project_2"></a>Editing the DSA Project</h4></div></div></div><p>Kermeta 3 is based on <a class="link" href="http://www.eclipse.org/xtend/index.html" target="_top">xTend</a>. The Execution Data and Execution Functions are defined through aspects weaved onto the metaclasses of the Domain Model.</p><div class="section" title="Defining the Execution Data"><div class="titlepage"><div><div><h5 class="title"><a name="_defining_the_execution_data_2"></a>Defining the Execution Data</h5></div></div></div><p>The Execution Data consist in attributes and references added to existing concepts (metaclasses) of the Abstract Syntax. They may also include new metaclasses which define the type of these new attributes and references.</p></div><div class="section" title="Defining the Execution Functions"><div class="titlepage"><div><div><h5 class="title"><a name="_defining_the_execution_functions_2"></a>Defining the Execution Functions</h5></div></div></div><p>The Execution Functions define how the Execution Data evolve during the execution of the model. Execution Functions can be implemented by defining the body of a method.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For now, Execution Functions are considered as <span class="strong"><strong>atomic, instantaneous and blocking</strong></span>. This means that any long computation will block the rest of the simulation, and concurrent Execution Functions are not executed in concurrence yet.</p></div><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>For technical reasons, the Domain Model (Ecore metamodel) must specify the signature of the Execution Functions as EOperations.</p></div></div></div><div class="section" title="Testing the Domain-Specific Actions"><div class="titlepage"><div><div><h4 class="title"><a name="_testing_the_domain_specific_actions"></a>Testing the Domain-Specific Actions</h4></div></div></div><p>It is possible to test the DSA (in particular the Execution Functions) by simply writing a simple program with a <span class="emphasis"><em>main</em></span> function (using Java or Xtend/Kermeta3). Create or load a model conform to your Domain Model and call the Execution Functions in the right order to verify there are no runtime exceptions or domain issues.</p></div></div><div class="section" title="Defining a Model of Concurrency and Communication (MoCC)"><div class="titlepage"><div><div><h3 class="title"><a name="section-defining-a-mocc"></a>Defining a Model of Concurrency and Communication (MoCC)</h3></div></div></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h4 class="title"><a name="_introduction_2"></a>Introduction</h4></div></div></div><p>In the GEMOC approach, the executability characterization for a given language is done through several steps that include: the description of the actions associated with the language concepts (i.e. the Executions Functions); the description of the data / attributes that capture the state of a model or its evolution (the Execution Data); the description of the underlying language model of concurrency (the MoCC constraints).</p><p>A Model of Concurrency and Communication (MoCC) represents the concurrency, synchronizations and the possibly timed causalities in the behavioral semantics of a language. It must represent the acceptable schedules of the atomic actions of the language, which represent both computation and communication.</p><p>In this part of the guide, we assume that achieving the first two points has already been done based on <a class="xref" href="ch03s02.html#section-define-dsa-project" title="Defining the Domain-Specific Actions (DSA) Project for concurrent language">the section called &#8220;Defining the Domain-Specific Actions (DSA) Project for concurrent language&#8221;</a>. In this part, we will mainly focus on the steps for the description and integration fo the model of concurrency in the language, once the <span class="emphasis"><em>EF</em></span> and <span class="emphasis"><em>ED</em></span> have been already taken into account and integrated to the language.
 The execution engine of the <span class="emphasis"><em>GEMOC Studio</em></span> is based on an event-based semantics, which means that events are used to activate the EF actions that can change the state of a model.</p><p>To describe and integrate the model of concurrency, we must 1) have a description of the useful events allowing activation of the <span class="emphasis"><em>EF</em></span>, 2) a mechanism to express the <span class="emphasis"><em>MoCC</em></span> constraints that apply on these events.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">1) is realized using the <span class="strong"><strong><a class="indexterm" name="d0e887"></a>ECL</strong></span> language whose description and use is provided below</li><li class="listitem">2) Is achieved through the <span class="strong"><strong><a class="indexterm" name="d0e896"></a>MoCCML</strong></span> language whose description and use is described below</li></ul></div></div><div class="section" title="The ECL approach to identify DSE and constraints"><div class="titlepage"><div><div><h4 class="title"><a name="_the_ecl_approach_to_identify_dse_and_constraints"></a>The ECL approach to identify DSE and constraints</h4></div></div></div><div class="section" title="Overview of ECL"><div class="titlepage"><div><div><h5 class="title"><a name="_overview_of_ecl"></a>Overview of ECL</h5></div></div></div><p>To enable the automatic generation of the execution model of a given DSML model, the MoCC is weaved into the context of specific concepts from the abstract syntax of the DSML. This contextualization is defined by a mapping between the elements of the abstract syntax and the constraints of the MoCC (defined using MoCCML). Examples of mapping are shown below.</p><p>The mapping defined in MoCCML is based on the notion of event, inspired by ECL <a class="link" href="https://hal.inria.fr/hal-00721169/" target="_top">ECL Description</a>, an extension of the Object Constraint Language OCL.
The separation of the mapping from the MoCC makes the MoCC independent of the DSML so that it can be reused.</p></div><div class="section" title="Creation of an ECL model GEMOC Studio"><div class="titlepage"><div><div><h5 class="title"><a name="_creation_of_an_ecl_model_gemoc_studio"></a>Creation of an ECL model GEMOC Studio</h5></div></div></div><p><span class="emphasis"><em>ECL</em></span> models are created via files with the extension <span class="emphasis"><em>.ecl. The _xDSML</em></span> environment enables the creation and / or opening of new <span class="emphasis"><em>ECL</em></span> project <a class="xref" href="ch01.html#section-gemoc-language-project" title="xDSML Project">the section called &#8220;xDSML Project&#8221;</a>.</p></div><div class="section" title="How to use ECL"><div class="titlepage"><div><div><h5 class="title"><a name="_how_to_use_ecl"></a>How to use ECL</h5></div></div></div><p>In this section, we show an examplified way to use ECL. The required steps to go from a given language to the integration of its concurrency model are presented.</p><div class="section" title="Import Language"><div class="titlepage"><div><div><h6 class="title"><a name="_import_language"></a>Import Language</h6></div></div></div><p>As shown in Listing <a class="xref" href="ch03s02.html#eclimport">???</a>, an <span class="emphasis"><em>ECL</em></span> file imports the extended language that contains the language metaclasses, the <span class="emphasis"><em>EF</em></span> and <span class="emphasis"><em>ED</em></span>. The <span class="emphasis"><em>ECL</em></span> language defines the notion of <span class="strong"><strong><a class="indexterm" name="d0e954"></a>import</strong></span> to import the extended metamodel (see import of <span class="emphasis"><em>dplExtended.ecore</em></span> in Listing <a class="xref" href="ch03s02.html#eclimport">???</a>).
The import is used to load all the concepts of language that are used to clarify: the <span class="emphasis"><em>EF</em></span> activation events; static properties numeric or Boolean values, and constraints associated with concepts.</p><a name="eclimport"></a><pre class="programlisting">import "platform:/resource/org.gemoc.model.dpl.dplextended/model/dplExtended.ecore"</pre></div><div class="section" title="Define Event-Action Creation"><div class="titlepage"><div><div><h6 class="title"><a name="_define_event_action_creation"></a>Define Event-Action Creation</h6></div></div></div><p>The <span class="emphasis"><em>ECL</em></span> model gives access to the concept of the language via the declaration of their package container. In the illustration below, the package container is <span class="emphasis"><em>dplextended</em></span>.  Every metaclass/ concept is declared as a <span class="emphasis"><em>context</em></span>. In a given context, we define the mapping between events and actions and the <span class="emphasis"><em>MoCC</em></span> constraints of the context.
The illustration shows the definition and mapping of events associated with the concept of <span class="emphasis"><em>Philosopher</em></span>. For the context <span class="emphasis"><em>Philosopher</em></span>, the events are used to enable its actions ie <span class="emphasis"><em>eat()</em></span> and <span class="emphasis"><em>think()</em></span> actions.
<span class="emphasis"><em>ECL</em></span> syntax for declaring the mapping Event / Action is as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">Define the type of the event: def: think: Event</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">When the event activate actions: the action associated to the event is accessed through the context via <span class="emphasis"><em>self.actionName()</em></span> (e.g. in Listing <a class="xref" href="ch03s02.html#eclContextEventDeclaration">???</a> <span class="emphasis"><em>Philosopher</em></span> <span class="emphasis"><em>self.think()</em></span> and <span class="emphasis"><em>self.eat()</em></span>)</li><li class="listitem">When the event does not trigger an action i.e. used as internal control events : Its declaration does not mention any related action (e.g. <span class="emphasis"><em>getrightFork</em></span>, <span class="emphasis"><em>getleftFork</em></span>, <span class="emphasis"><em>putrightFork</em></span>, <span class="emphasis"><em>putleftFork</em></span>)</li></ul></div></li><li class="listitem">Finally, we can define local attributes to capture the value of static properties that can be for instance integers or booleans (e.g. <span class="emphasis"><em>def: eatcycleMax: Integer = self.eatCycles</em></span>)
The above steps specify the declaration of events and attributes that are used to control the actions for each language concept. We can focus on the description of the model of concurrency defined using <span class="emphasis"><em>MoCCML</em></span>.</li></ul></div><a name="eclContextEventDeclaration"></a><pre class="programlisting">package dplextended
	context Philosopher
		def: think : Event = self.think()
		def: getrightFork : Event = self
		def: getleftFork : Event = self
		def: eat : Event = self.eat()
		def: putrightFork : Event = self
		def: putleftFork : Event = self
		def: thinkcycleMax : Integer = self.thinkCycles
		def: eatcycleMax : Integer = self.eatCycles
endpackage</pre><p>The latter phase is done in two steps: the implementation of the execution control constraints with <span class="emphasis"><em>MoCCML</em></span>; the use of these constraints in the context definition to specify how the events should be scheduled (determine their causalities).</p></div></div></div><div class="section" title="The MoCCML approach to define constraints"><div class="titlepage"><div><div><h4 class="title"><a name="_the_moccml_approach_to_define_constraints"></a>The MoCCML approach to define constraints</h4></div></div></div><p>This section presents the MoCCML editor that supports the edition of <span class="emphasis"><em>MoCC_s. To keep the de&#64257;ned models formal and to provide a solver for the _MoCC</em></span>, an operational semantics and a solver based on this formal semantics were defined. For more information on the operational semantics the reader can refer to <a class="link" href="https://hal.inria.fr/hal-01060601v1" target="_top">MoCCML Operational Semantics</a>.</p><div class="section" title="Creating a MoCCML model in the GEMOC Studio"><div class="titlepage"><div><div><h5 class="title"><a name="_creating_a_moccml_model_in_the_gemoc_studio"></a>Creating a MoCCML model in the GEMOC Studio</h5></div></div></div><p>The <span class="emphasis"><em>MoCCML</em></span> models are created via files with an <span class="emphasis"><em>.moccml extension. They are also natively created from the dashboard _xDSML</em></span>, where you can create a <span class="emphasis"><em>MoCC</em></span> project. The project defines an empty model _.moccml with just the name of the library to be created. For a graphical representation of the models, you have to right-click on the file (New Representation File) and run next until the creation of the _.aird representation. This procedure is described in the Sirius tutorial <a class="link" href="http://www.eclipse.org/sirius/doc/" target="_top">Sirius documentation</a> and <a class="link" href="http://www.eclipse.org/sirius/doc/specifier/Sirius%20Specifier%20Manual.html" target="_top">Sirius Specifier Manual</a> to create new diagrams starting from a model whose graphical editor was made from Sirius.</p></div><div class="section" title="Overview de MoCCML"><div class="titlepage"><div><div><h5 class="title"><a name="_overview_de_moccml"></a>Overview de MoCCML</h5></div></div></div><p><span class="emphasis"><em>MoCCML</em></span> is a declarative meta-language specifying constraints between the events of a <span class="emphasis"><em>MoCC</em></span>. At any moment during a run, an event that does not violate the constraints can occur. The constraints are grouped in libraries that specify <span class="emphasis"><em>MoCC</em></span> speci&#64257;c constraints. The constraints are eventually instantiated to de&#64257;ne the execution model of a speci&#64257;c model. The execution model is a symbolic representation of all the acceptable schedules for a particular model.
<span class="emphasis"><em>MoCCML</em></span> is based on the principle of defining constraints on events. There are two categories of constraint de&#64257;nitions: the Declarative De&#64257;nitions and the Constraint Automata De&#64257;nitions. Each constraint definition has an associated ConstraintDeclaration that defines the prototype of the constraint.</p></div><div class="section" title="Presentation of the MoCCML Editor"><div class="titlepage"><div><div><h5 class="title"><a name="_presentation_of_the_moccml_editor"></a>Presentation of the MoCCML Editor</h5></div></div></div><p>The concrete syntax of <span class="emphasis"><em>MoCCML</em></span> is implemented as a combination of graphical and textual syntaxes to provide the most appropriate representation for each part of a <span class="emphasis"><em>MoCC</em></span> model library.
The graphical syntax can be divided into two levels of representation: one for the definition of the <span class="emphasis"><em>MoCC</em></span> libraries (the declaration and definition of the automata constraints); another for the implementation of the constraints in the form of automata. For instance:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">The first level of representation contains elements as illustrated in Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a>. The represented model imports two <span class="emphasis"><em>CCSL</em></span> libraries (<span class="emphasis"><em>kernel.ccslLib</em></span> and <span class="emphasis"><em>CCSL.ccslLib</em></span>). The imported libraries provide predefined types that are used to define formal parameters such as DiscreteClocks, Integers, etc. Each defined Relation Declaration is associated to a Automata constraint definition. The association is done through the <span class="emphasis"><em>Set Declaration Relation</em></span> link.</li><li class="listitem">The second level of graphical representation defines the graphical syntax for the modeling of the Automata constraints.</li><li class="listitem">The overall <span class="emphasis"><em>MoCC</em></span> models are serialized to a textual syntax, which means that the graphical models are transformed into their equivalent representation in a textual formal. <span class="strong"><strong><a class="indexterm" name="d0e1143"></a>Both representations (graphical or textual) can be used for edition of models</strong></span>.
Moreover, we define the integration of an embedded textual editor in the graphical representation to focus on specific parts of the <span class="emphasis"><em>MoCC</em></span> model that are better edited using a textual syntax (eg trigger, the guards and the actions on transitions). Embedded editors are called by double-clic, and are placed on specific graphical edition elements (Relation Declaration, Relation Definition, DeclarationBlock, Transition).</li></ul></div></div><div class="section" title="Example-Driven use of MoCCML"><div class="titlepage"><div><div><h5 class="title"><a name="_example_driven_use_of_moccml"></a>Example-Driven use of MoCCML</h5></div></div></div><p>NB: <span class="emphasis"><em>MoCCML</em></span> has multiple pallets to instantiate a library. The pallets are located on the right branch of the editor. The creation of new library is preceded by an import of the native <span class="emphasis"><em>CCSL</em></span> libraries (<span class="emphasis"><em>kernel.ccslLib</em></span>, <span class="emphasis"><em>CCSL.ccslLib</em></span>) which provide primitives for the description of events and variables that are handled by the constraints in the <span class="emphasis"><em>MoCC</em></span> library. We use the third pallet in Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a>to import such <span class="emphasis"><em>CCSL</em></span> libraries.</p><div class="figure"><a name="figure-glw-screenshot-of-moccmlLevelFirst"></a><p class="title"><b>Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.</b></p><div class="figure-contents"><div class="mediaobject"><img src="./Guide/images/eclmoccml/moccmlLevFirst.png" width="800" alt="Screenshot of MoCCML First Level of Edition"></div></div></div><br class="figure-break"><div class="section" title="Creating MoCC Libraries"><div class="titlepage"><div><div><h6 class="title"><a name="_creating_mocc_libraries"></a>Creating MoCC Libraries</h6></div></div></div><p>As shown in Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a>, creating new <span class="emphasis"><em>MoCC</em></span> libraries can be done by using the first two pallets on the right (Library Edition, New Library &amp; Required Feature). In these pallets, the element (Library New Library + New Relationship and Relationship) can be used for the instantiation of a new <span class="emphasis"><em>MoCC</em></span> library. The two are distinguished by the fact that the last mentioned will create a new library of <span class="emphasis"><em>MoCC</em></span>, while adding a default Relation Declaration. In Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a> we create a new Library called <span class="emphasis"><em>RendezVous_Relations</em></span>.</p></div><div class="section" title="Declaring the constrained events"><div class="titlepage"><div><div><h6 class="title"><a name="_declaring_the_constrained_events"></a>Declaring the constrained events</h6></div></div></div><p>In a <span class="emphasis"><em>MoCC</em></span> library, we define constraints and their declarations. The declarations identify events and parameters to be considered in the implementation of the constraint. In the editor, the declaration is made using the two above mentioned pallets, and using the elements in the pallets i.e.: <span class="emphasis"><em>New Relationship Declaration</em></span> and <span class="emphasis"><em>New Relationship Declaration +</em></span>. The two differ in that the latter creates a Relation Declaration with a default formal parameter declaration. In the Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a>, we create two relation declarations (<span class="emphasis"><em>ForkConstraintDecl</em></span> and <span class="emphasis"><em>PhilosopherConstraintDecl</em></span>). Listing <a class="xref" href="ch03s02.html#philoDeclarationTextual">???</a> also shows the equivalent textual code generated for the <span class="emphasis"><em>PhilosopherConstraintDecl</em></span>.</p><a name="philoDeclarationTextual"></a><pre class="programlisting">RelationDeclaration PhilosopherConstraintDcl(
			pthink : clock,
			grfork : clock,
			glfork : clock,
			peat : clock,
			prfork : clock,
			plfork : clock,
			thinkCyc:int,
			eatCyc:int
		)</pre></div><div class="section" title="Defining the constraints"><div class="titlepage"><div><div><h6 class="title"><a name="_defining_the_constraints"></a>Defining the constraints</h6></div></div></div><p>The implementation of constraints can be specified textually or graphically. Graphically, the first two pallets are used to create new definitions of constraints associated with their declarations. Constraint definitions is done using the menu items (<span class="emphasis"><em>New Automata Definition</em></span> and <span class="emphasis"><em>New Automata Definition +</em></span>). In Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelFirst" title="Figure&nbsp;3.1.&nbsp;Screenshot of the First graphical level of Edition in MoCCML.">Figure&nbsp;3.1, &#8220;Screenshot of the First graphical level of Edition in MoCCML.&#8221;</a>, the following constraints are specified: <span class="emphasis"><em>ForkConstraintDef</em></span>, <span class="emphasis"><em>PhilosopherConstraintDef</em></span>). At this stage, we toured the main notions that can be set on the first level of graphical description with <span class="emphasis"><em>MoCCML</em></span>.
To navigate in the second level of graphical description (Constraint implementation), one should right-click on a specified constraint definition using (Open Diagram / New Diagram). Open Diagram will navigate to an existing diagram; New Diagram will create a new diagram to edit.
The <span class="emphasis"><em>MoCCML</em></span> Editor offers 3 different pallets for: editing the automata, defining the local variables and editing the transitons (ie adding <span class="emphasis"><em>Trigger</em></span>, <span class="emphasis"><em>Guard</em></span>, <span class="emphasis"><em>Actions</em></span>). Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelSecond" title="Figure&nbsp;3.2.&nbsp;Screenshot of the Second graphical level of Edition in MoCCML (Constraint Implementation).">Figure&nbsp;3.2, &#8220;Screenshot of the Second graphical level of Edition in MoCCML (Constraint Implementation).&#8221;</a> shows a simple example with two control states. An additional Layer displays the details of the transitions (<span class="emphasis"><em>Trigger</em></span>, <span class="emphasis"><em>Guard</em></span>, <span class="emphasis"><em>Action</em></span>) as shown in Figure <a class="xref" href="ch03s02.html#figure-glw-screenshot-of-moccmlLevelSecond" title="Figure&nbsp;3.2.&nbsp;Screenshot of the Second graphical level of Edition in MoCCML (Constraint Implementation).">Figure&nbsp;3.2, &#8220;Screenshot of the Second graphical level of Edition in MoCCML (Constraint Implementation).&#8221;</a>, see yellow boxes.
Besides, editing <span class="emphasis"><em>DeclarationBlock</em></span> boxes and <span class="emphasis"><em>details in Transitions</em></span> can be done using embedded text editor by double-clicking on the related boxes. We can then edit the properties of transitions and local variables textually.</p><p>One can define the desired set of constraints on the concepts of language using the <span class="emphasis"><em>MoCCML</em></span> editor. To see the text code corresponding to the serialization of the edited <span class="emphasis"><em>MoCC</em></span> models, the user can open the _.moccml file. Editing can also be directly made from this file and all the changes will be reflected in the graphical editor.
The use of constraints is shown in the next section.</p><div class="figure"><a name="figure-glw-screenshot-of-moccmlLevelSecond"></a><p class="title"><b>Figure&nbsp;3.2.&nbsp;Screenshot of the Second graphical level of Edition in MoCCML (Constraint Implementation).</b></p><div class="figure-contents"><div class="mediaobject"><img src="./Guide/images/eclmoccml/moccmlLevSecond.png" width="800" alt="Screenshot of MoCCML Second Level of Edition"></div></div></div><br class="figure-break"></div><div class="section" title="Using the constraints on the ECL"><div class="titlepage"><div><div><h6 class="title"><a name="_using_the_constraints_on_the_ecl"></a>Using the constraints on the ECL</h6></div></div></div><p>The <span class="emphasis"><em>MoCC</em></span> constraints models can be used in the <span class="emphasis"><em>ECL</em></span> file on concepts which they are attached. To declare the constraint on the events, we re-declare the context of the concept then define an invariant <span class="emphasis"><em>inv</em></span>, see Listing <a class="xref" href="ch03s02.html#eclContextConstraintUse">???</a>. In this listing we also import the <span class="emphasis"><em>MoCCML</em></span> library that was defined previously (i.e. rendez_vous.moccml)
For instance, the invariant related to the context Philosopher (<span class="emphasis"><em>PhilosopherConstraintInv</em></span>) uses the <span class="emphasis"><em>PhilosopherConstraintDef</em></span> via its <span class="emphasis"><em>PhilosopherConstraintDcl</em></span> declaration? It takes as input the set of control events and static variables used to calculate the causality between events.</p><a name="eclContextConstraintUse"></a><pre class="programlisting">ECLimport "platform:/resource/org.gemoc.dpl.xdsml.mocc.model/mocc/rendez_vous.moccml"
ECLimport "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib"
ECLimport "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib"

package dplextended
	context Philosopher
		def: think : Event = self.think()
		def: getrightFork : Event = self
		def: getleftFork : Event = self
		def: eat : Event = self.eat()
		def: putrightFork : Event = self
		def: putleftFork : Event = self
		def: thinkcycleMax : Integer = self.thinkCycles
		def: eatcycleMax : Integer = self.eatCycles

	context Philosopher
	inv PhilosopherConstraintInv:
		Relation PhilosopherConstraintDcl(
                self.think,
                self.getrightFork,
                self.getleftFork,self.eat,
                self.putrightFork,
                self.putleftFork,
                self.thinkcycleMax,
                self.eatcycleMax
                )
endpackage</pre></div></div></div></div><div class="section" title="Defining the Domain-Specific Events (DSE)"><div class="titlepage"><div><div><h3 class="title"><a name="_defining_the_domain_specific_events_dse"></a>Defining the Domain-Specific Events (DSE)</h3></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This section is relevant to the definition of <span class="strong"><strong>concurrent</strong></span> xDSMLs.</p></div><div class="section" title="Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="_purpose_5"></a>Purpose</h4></div></div></div><p>The DSE define a mapping between MoccEvents from the MoCC and the Execution Functions. They specify the coordination between what happens in the MoCC, depending on its constraints, and which operations must be called in the model (thus resulting in changes in the Execution Data).
They are also exposed as the behavioral interface of the xDSML, based on which the Behavioral COmposition Operator Language (BCOoL) defines the composition of xDSMLs.</p></div><div class="section" title="Creating the DSE Project"><div class="titlepage"><div><div><h4 class="title"><a name="_creating_the_dse_project"></a>Creating the DSE Project</h4></div></div></div><p>Create an empty Plug-in Project. In this project, create a new file with the ".GEL" extension. The DSE can be defined using the <span class="strong"><strong>Gemoc Events Language</strong></span> (GEL).</p></div><div class="section" title="Editing the DSE Project"><div class="titlepage"><div><div><h4 class="title"><a name="_editing_the_dse_project"></a>Editing the DSE Project</h4></div></div></div><p>The first step to designing the DSE in GEL consists in importing the MoCC2AS Mapping (ECL file) and the Domain Model (Ecore metamodel) of the xDSML. You can do so by using the <span class="emphasis"><em>import platform:/resource/&#8230;&#8203;</em></span> syntax at the beginning of the file.</p><div class="section" title="Defining an Atomic Domain-Specific Event"><div class="titlepage"><div><div><h5 class="title"><a name="_defining_an_atomic_domain_specific_event"></a>Defining an Atomic Domain-Specific Event</h5></div></div></div><p>Atomic Domain-Specific Events realize a 1-to-1 mapping between the MoccEvents and the Execution Functions of the xDSML.
An atomic DSE is defined using the following syntax:</p><pre class="screen">DSE &lt;name&gt;:
  upon &lt;MoccEvent&gt;
  triggers &lt;Path-to-ExecutionFunction&gt;
end</pre><p>Where:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">&lt;name&gt; is the name of the Domain-Specific Event;</li><li class="listitem">&lt;MoccEvent&gt; is any MoccEvent from the MoCC2AS Mapping. This will also automatically define the DSE in the same context as the MoccEvent referenced, thus defining the starting point of navigation expressions from this DSE;</li><li class="listitem">&lt;Path-to-ExecutionFunction&gt; is a navigation path from the context of this DSE to an Execution Function.</li></ul></div><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In case of difficulty, make use of the auto-completion feature.</p></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The implicit context of a Domain-Specific Event is inferred from the context in which its associated MoccEvent is defined in the MoCC2AS Mapping. Therefore, the DSE will be usable for any instance in the model of the context of the DSE. For instance if a DSE is mapped to a MoccEvent defined in the context of the metaclass <span class="emphasis"><em>Transition</em></span>, and there are 3 Transitions in the model being executed, this DSE will be usable for each of the 3 Transitions of the model.</p></div></div><div class="section" title="Semantics of Atomic Domain-Specific Events"><div class="titlepage"><div><div><h5 class="title"><a name="_semantics_of_atomic_domain_specific_events"></a>Semantics of Atomic Domain-Specific Events</h5></div></div></div><p>Upon an occurrence of the associated MoccEvent, an occurrence of the Domain-Specific Event is created and consumed by the GEMOC Execution Engine. Its consumption triggers the execution of the designated Execution Function.</p></div></div></div><div class="section" title="Defining the Feedback Specification"><div class="titlepage"><div><div><h3 class="title"><a name="_defining_the_indexterm_primary_feedback_specification_primary_indexterm_feedback_specification"></a>Defining the <a class="indexterm" name="d0e1401"></a>Feedback Specification</h3></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This section is relevant to the definition of <span class="strong"><strong>concurrent</strong></span> xDSMLs.</p></div><div class="section" title="Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="_purpose_6"></a>Purpose</h4></div></div></div><p>Many languages need to be able to parameterize their control flow with their data flow. For instance, conditional statements like <span class="emphasis"><em>if&#8230;&#8203;then&#8230;&#8203;else</em></span> or <span class="emphasis"><em>switch&#8230;&#8203;case</em></span> statements depend on the result of a boolean expression.
Since the GEMOC approach at designing xDSMLs promotes the separation of the concurrency (MoCC from the domain-specific data (DSA), there needs to be a form of communication from the DSA to the MoCC. For instance, the MoCC of an xDSML with a conditional statement specifies that after evaluating the condition, either the 'then' or the 'else' branch will be taken (in exclusion from one another), while the DSA provide the Execution Function that evaluates the condition, returning a boolean value. Making the link between the 'true' value and the 'then' branch, and between the 'false' value and the 'else' branch is the role of the Feedback Specification.
More formally, the Feedback Specification specifies how domain data returned by an Execution Function must be interpreted to parameterize the MoCC. The Feedback Specification consists in a set of Feedback Policies which are associated to the atomic Domain-Specific Events. Therefore, the Feedback Specification is also done using <a class="indexterm" name="d0e1422"></a>GEL.</p></div><div class="section" title="Creating a Feedback Policy"><div class="titlepage"><div><div><h4 class="title"><a name="_creating_a_indexterm_primary_feedback_policy_primary_indexterm_feedback_policy"></a>Creating a <a class="indexterm" name="d0e1429"></a>Feedback Policy</h4></div></div></div><p>A Feedback Policy is associated to an atomic DSE by extending the syntax for defining the atomic DSE as follows:</p><pre class="screen">DSE &lt;name&gt;:
  upon &lt;MoccEvent&gt;
  triggers &lt;Path-to-ExecutionFunction&gt; returning &lt;resultName&gt;
  feedback:
    [&lt;filter1&gt;] =&gt; allow &lt;PathToMoccEventConsequence1&gt;
    [&lt;filter2&gt;] =&gt; allow &lt;PathToMoccEventConsequence2&gt;
    ...
    default =&gt; allow &lt;PathToMoccEventDefaultConsequence&gt;
  end
end</pre><p>Where:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">&lt;resultName&gt; is a local variable which will be affected with the value returned by the associated Execution Function;</li><li class="listitem">Between the <span class="emphasis"><em>feedback</em></span> and <span class="emphasis"><em>end</em></span> keywords, a set of Feedback Rules are defined (including a default Feedback Rule, with the <span class="emphasis"><em>default</em></span> keyword). A Feedback Rule is composed of a filter (between squared brackets) and a consequence;</li><li class="listitem">&lt;filterN&gt; are predicates, most likely using &lt;resultName&gt; which define whether or not this Feedback Rule must be applied;</li><li class="listitem">&lt;PathToMoccEventConsequenceN&gt; is a navigation expression to a MoccEvent which specifies which MoccEvent is allowed as a result of the data returned by the Execution Function.</li></ul></div><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In case of difficulty, make use of the auto-completion feature.</p></div></div><div class="section" title="Semantics of the Feedback Policy"><div class="titlepage"><div><div><h4 class="title"><a name="_semantics_of_the_feedback_policy"></a>Semantics of the Feedback Policy</h4></div></div></div><p>When the Execution Function associated to a DSE returns a result, the filter of every Feedback Policy is evaluated. If none of the filters is validated, then the default rule is applied. Else, the collection of rules for which the filter validated are applied.
For each rule to apply, the associated consequence is allowed to have occurrences in upcoming steps of execution. This is done by the Execution Engine by filtering out some solutions provided by the MoCC interpreter and only allowing the ones complying with the Feedback Specification.</p></div></div><div class="section" title="Exhaustive Exploration and Verification at Language Design Time"><div class="titlepage"><div><div><h3 class="title"><a name="section-exhaustive-exploration-lw"></a>Exhaustive Exploration and Verification at Language Design Time</h3></div></div></div><p>One benefit of assigning an execution semantics onto a DSL is to pave the way for exhaustive exploration. Exhaustive exploration is a technique used in complex and safety system design to ensure the correct adequacy between the system requirements and the real behavior of the system. This is made possible by exploring and verifying properties on an exhaustive finite state space of the system representing the whole set of relevant configurations your system may reach.</p><p>Gemoc provides the first step towards exploration and verification by building the graph of all the possible schedules of a system model constrained with <span class="strong"><strong><a class="indexterm" name="d0e1477"></a>MoCCML</strong></span>. It can then be used in a model-checking tool to verify behavioral properties of the <span class="strong"><strong><a class="indexterm" name="d0e1483"></a>MoCCML</strong></span> models. Thanks to Gemoc approach the execution model is explicited and can be manipulated to for instance:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Verify temporal logic properties (safety and liveness) on the state space graph structure;</li><li class="listitem">Extract a schedule that optimizes specific objectives;</li><li class="listitem">Extract system properties by static analysis of an event-graph representation of the execution model.</li></ul></div><p>In the Gemoc approach the steps toward exploration and verification during language design are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Define an executable model and its mapping on a DSL(we assume it has already been defined see <a class="xref" href="ch03s02.html#section-defining-a-mocc" title="Defining a Model of Concurrency and Communication (MoCC)">the section called &#8220;Defining a Model of Concurrency and Communication (MoCC)&#8221;</a>);</li><li class="listitem">Generate a configuration file from <span class="strong"><strong><a class="indexterm" name="d0e1510"></a>ECL</strong></span> model to target an exhaustive exploration tool;</li></ul></div><p>In the Gemoc approach the steps toward exploration and verification during modeling design are described in <a class="xref" href="ch09s03.html" title="Exhaustive Exploration and Verification at Model Design Time">the section called &#8220;Exhaustive Exploration and Verification at Model Design Time&#8221;</a>:
The flow toward exhaustive exploration and verification in Gemoc is presented in figure <a class="xref" href="ch03s02.html#figure-exploration-flow" title="Figure&nbsp;3.3.&nbsp;The exploration and verification flow in Gemoc">Figure&nbsp;3.3, &#8220;The exploration and verification flow in Gemoc&#8221;</a> and described in the following sections.</p><div class="figure"><a name="figure-exploration-flow"></a><p class="title"><b>Figure&nbsp;3.3.&nbsp;The exploration and verification flow in Gemoc</b></p><div class="figure-contents"><div class="mediaobject"><img src="./Guide/images/exhaustive_exploration/flow.png" width="600" alt="The Exploration and Verification Flow in Gemoc"></div></div></div><br class="figure-break"><div class="section" title="Generating inputs for Exhaustive Exploration tools : T1 at Language Level"><div class="titlepage"><div><div><h4 class="title"><a name="_generating_inputs_for_exhaustive_exploration_tools_emphasis_t1_emphasis_at_language_level"></a>Generating inputs for Exhaustive Exploration tools : <span class="emphasis"><em>T1</em></span> at Language Level</h4></div></div></div><p>ECL specification is the starting point toward exploration. In this specification we define events associated with the actions of the <span class="strong"><strong><a class="indexterm" name="d0e1539"></a>DSA</strong></span> and also events associated with the <span class="strong"><strong><a class="indexterm" name="d0e1545"></a>DSE</strong></span> events. On these event bindings we apply the <span class="strong"><strong><a class="indexterm" name="d0e1551"></a>MoccML</strong></span> relations of the MoC Library to schedule the events. A finite state space of a system uses such scheduling constraints and therefore a configuration file to target an exhaustive exploration tool must be generated:</p><p><span class="emphasis"><em>T1</em></span> transformation generates a configuration file to later target exhaustive exploration or simulation tools.  <span class="emphasis"><em>T1</em></span> takes as input the <span class="strong"><strong><a class="indexterm" name="d0e1564"></a>ECL</strong></span> mapping definition between the DSL and the <span class="strong"><strong><a class="indexterm" name="d0e1570"></a>MoCCML</strong></span> to generate a transformation <span class="emphasis"><em>T2</em></span> describing transformation rules that will be used to produce the processes for the DSL related functions and data (DSA) and the behavioral processes corresponding to the <span class="strong"><strong><a class="indexterm" name="d0e1579"></a>MoCCML</strong></span> constraints.</p><p><span class="emphasis"><em>T1</em></span> is automatically generated from ecl model and results are stored in <span class="strong"><strong><a class="indexterm" name="d0e1589"></a>mtl-gen</strong></span> folder.</p><p>However to execute <span class="emphasis"><em>T1</em></span> manually right-click on the <span class="strong"><strong><a class="indexterm" name="d0e1600"></a>ECL</strong></span> file &#8594; <span class="inlinemediaobject"><img src="./Guide/images/exhaustive_exploration/clocksystem_logo_32x32.png" width="16" height="16" alt="clocksystem_logo_32x32"></span>Exhaustive Exploration  &#8594; <span class="inlinemediaobject"><img src="./Guide/images/exhaustive_exploration/cs_t1_16x16.png" width="16" height="16" alt="cs_t1_16x16"></span>Generate ClockSystem transformation from ECL model  as illustrated in figure <a class="xref" href="ch03s02.html#figure-t1-t2" title="Figure&nbsp;3.4.&nbsp;Using T1 Tranformation">Figure&nbsp;3.4, &#8220;Using T1 Tranformation&#8221;</a>.<span class="emphasis"><em>T2</em></span> is generated in the repository &lt;mtl-gen&gt;.</p><div class="figure"><a name="figure-t1-t2"></a><p class="title"><b>Figure&nbsp;3.4.&nbsp;Using T1 Tranformation</b></p><div class="figure-contents"><div class="mediaobject"><img src="./Guide/images/exhaustive_exploration/t1_t2.png" width="500" alt="Using T1 Tranformation"></div></div></div><br class="figure-break"></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Make a language executable&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="Guide.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Define an animator</td></tr></table></div></body></html>