<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>8.3.&nbsp;Exhaustive Exploration and Verification at Model Design Time</title><link rel="stylesheet" href="css/docbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="Guide.html" title="GEMOC Studio User Guide"><link rel="up" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Executing model"><link rel="prev" href="ch08s02.html" title="8.2.&nbsp;Executing model with the Concurrent Engine"><link rel="next" href="ch09.html" title="Chapter&nbsp;9.&nbsp;Coordinating Model Execution"><base xmlns:fo="http://www.w3.org/1999/XSL/Format" target="body"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.3.&nbsp;Exhaustive Exploration and Verification at Model Design Time</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;8.&nbsp;Executing model</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch09.html">Next</a></td></tr></table><hr></div><div class="section" title="8.3.&nbsp;Exhaustive Exploration and Verification at Model Design Time"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section-exhaustive-exploration-mw"></a>8.3.&nbsp;Exhaustive Exploration and Verification at Model Design Time</h2></div></div></div><p>One benefit of assigning an execution semantics onto a DSL is to pave the way for exhaustive exploration. Exhaustive exploration is a technique used in complex and safety system design to ensure the correct adequacy between the system requirements and the real behavior of the system. This is made possible by exploring and verifying properties on an exhaustive finite state space of the system representing the whole set of relevant configurations your system may reach.</p><p>Gemoc provides the first step towards exploration and verification by building the graph of all the possible schedules of a system model constrained with <span class="strong"><strong><a class="indexterm" name="d0e2387"></a>MoCCML</strong></span>. It can then be used in a model-checking tool to verify behavioral properties of the <span class="strong"><strong><a class="indexterm" name="d0e2393"></a>MoCCML</strong></span> models. Thanks to Gemoc approach the execution model is explicited and can be manipulated to for instance:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Verify temporal logic properties (safety and liveness) on the state space graph structure;</li><li class="listitem">Extract a schedule that optimizes specific objectives;</li><li class="listitem">Extract system properties by static analysis of an event-graph representation of the execution model.</li></ul></div><p>In the Gemoc approach the steps toward exploration and verification during language design are described in <a class="xref" href="">???</a>.</p><p>Besides the steps toward exploration and verification during modeling design are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Generate a model for an exhaustive exploration tool using the configuration file;</li><li class="listitem">Invoke <span class="strong"><strong><a class="indexterm" name="d0e2422"></a>ClockSystem</strong></span>'s services to generate a finite state space of the system;</li><li class="listitem">Formalize a set of properties to verify(in <span class="strong"><strong><a class="indexterm" name="d0e2431"></a>CDL</strong></span> language for instance);</li><li class="listitem">Use a model checking infrastructure to perform the verification of properties on the finite state space(like <span class="emphasis"><em>OBP</em></span>).</li></ul></div><p>The flow toward exhaustive exploration and verification in Gemoc is presented in figure <a class="xref" href="">???</a> and described in the following sections.</p><div class="section" title="8.3.1.&nbsp;Generating inputs for Exhaustive Exploration tools : T2 at Modeling Level"><div class="titlepage"><div><div><h3 class="title"><a name="_generating_inputs_for_exhaustive_exploration_tools_emphasis_t2_emphasis_at_modeling_level"></a>8.3.1.&nbsp;Generating inputs for Exhaustive Exploration tools : <span class="emphasis"><em>T2</em></span> at Modeling Level</h3></div></div></div><p>ECL specification is the starting point toward exploration. In this specification we define events associated with the actions of the <span class="strong"><strong><a class="indexterm" name="d0e2455"></a>DSA</strong></span> and also events associated with the <span class="strong"><strong><a class="indexterm" name="d0e2461"></a>DSE</strong></span> events. On these event bindings we apply the <span class="strong"><strong><a class="indexterm" name="d0e2467"></a>MoccML</strong></span> relations of the MoC Library to schedule the events. A finite state space of a system uses such scheduling constraints and therefore is generated from using a transformation:</p><p>In the Modeling workbench where the DSL instance model is realized, the transformation <span class="emphasis"><em>T2</em></span> takes as input the instance system model to generate a <span class="emphasis"><em>MOCC</em></span> instance model described in <span class="strong"><strong><a class="indexterm" name="d0e2481"></a>ClockSystem</strong></span> specification format. Notice that currently you have to copy the &lt;clocksystem-gen&gt; repository previously generated in your project. To call this transformation the right-click on your model &#8594; Exhaustive Exploration &#8594; Generate ClockSystem file from DSL model. <span class="emphasis"><em>T2</em></span>  generates the .clocksystem file corresponding to the Mocc-based specification model to take as input in <span class="strong"><strong><a class="indexterm" name="d0e2490"></a>ClockSystem</strong></span>.</p><div class="figure"><a name="figure-t2-cs"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/t2_cs.png" width="500" alt="Using T2 Tranformation"></div></div><p class="title"><b>Figure&nbsp;8.1.&nbsp;Using T2 Tranformation</b></p></div><br class="figure-break"></div><div class="section" title="8.3.2.&nbsp;ClockSystem"><div class="titlepage"><div><div><h3 class="title"><a name="__emphasis_role_strong_indexterm_primary_clocksystem_primary_indexterm_clocksystem_emphasis"></a>8.3.2.&nbsp;<span class="strong"><strong><a class="indexterm" name="d0e2507"></a>ClockSystem</strong></span></h3></div></div></div><div class="section" title="8.3.2.1.&nbsp;Description"><div class="titlepage"><div><div><h4 class="title"><a name="_description_2"></a>8.3.2.1.&nbsp;Description</h4></div></div></div><p><span class="strong"><strong><a class="indexterm" name="d0e2516"></a>ClockSystem</strong></span> is a meta-described clock-constraint engine developped during Gemoc which embeds a formal model of logical time. It relies on the primitives provided by Clock Constraint Specification Language (CCSL) defining a simple yet powerful toolkit for logical time specifications. It also extends the CCSL language, through an automata-based approach, with domain-specific user-defined operators and provides an embedded DSL for writing executable specification in a language close to the abstract CCSL notation.</p><p><span class="strong"><strong><a class="indexterm" name="d0e2523"></a>ClockSystem</strong></span> toolkit provides the possibility to perform exhaustive reachability analysis of relation specifications (e.g. <span class="strong"><strong><a class="indexterm" name="d0e2529"></a>MoCCML</strong></span> or CCSL specifications). The possibility to exhaustively explore the state-space of a given specification paves the way to verification of properties by model-checking as such an interface with the <span class="emphasis"><em>OBP</em></span> model-checking toolkit was developed.</p></div><div class="section" title="8.3.2.2.&nbsp;Using ClockSystem"><div class="titlepage"><div><div><h4 class="title"><a name="_using_clocksystem"></a>8.3.2.2.&nbsp;Using ClockSystem</h4></div></div></div><p><span class="strong"><strong><a class="indexterm" name="d0e2542"></a>ClockSystem</strong></span> consists of an image and a Pharo VM which depends on the operating system. Their integration in Gemoc studio can be realized through the discovery mecanism. To activate discovery mecanism click on the Gemoc icon in toolbar as illustrated <a class="xref" href="ch08s03.html#figure-discovery" title="Figure&nbsp;8.2.&nbsp;Discovery">Figure&nbsp;8.2, &#8220;Discovery&#8221;</a>.</p><div class="figure"><a name="figure-discovery"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/discovery.png" width="400" alt="Discovery"></div></div><p class="title"><b>Figure&nbsp;8.2.&nbsp;Discovery</b></p></div><br class="figure-break"><p>Select <span class="strong"><strong><a class="indexterm" name="d0e2561"></a>ClockSystem</strong></span> add on <a class="xref" href="ch08s03.html#figure-discovery-comp" title="Figure&nbsp;8.3.&nbsp;Discovery Components">Figure&nbsp;8.3, &#8220;Discovery Components&#8221;</a> and click on <span class="emphasis"><em>Finish</em></span>.</p><div class="figure"><a name="figure-discovery-comp"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/discovery_comp.png" width="400" alt="Discovery Components"></div></div><p class="title"><b>Figure&nbsp;8.3.&nbsp;Discovery Components</b></p></div><br class="figure-break"><p>Select the unique feature and <span class="emphasis"><em>Next</em></span> as illustrated in <a class="xref" href="ch08s03.html#figure-dicovery-cs" title="Figure&nbsp;8.4.&nbsp;Discovery Clocksystem">Figure&nbsp;8.4, &#8220;Discovery Clocksystem&#8221;</a>. Then again select <span class="emphasis"><em>Next</em></span>.</p><div class="figure"><a name="figure-dicovery-cs"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/discovery_cs.png" width="400" alt="Discovery for ClockSystem"></div></div><p class="title"><b>Figure&nbsp;8.4.&nbsp;Discovery Clocksystem</b></p></div><br class="figure-break"><p>Approve the licence and click <span class="emphasis"><em>Finish</em></span>. Gemoc must be restarted(this should be automatically prompted to the user).</p><div class="figure"><a name="figure-dicovery-lic"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/discovery_lic.png" width="400" alt="Approve licence of ClockSystem"></div></div><p class="title"><b>Figure&nbsp;8.5.&nbsp;Approve licensing</b></p></div><br class="figure-break"><div xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p xmlns=""><span class="strong"><strong><a class="indexterm" name="d0e2616"></a>ClockSystem</strong></span> VM and Image will be extracted in your default temporary folder at the first call of Clocksystem services. Although Gemoc provides an action to invoke <span class="strong"><strong><a class="indexterm" name="d0e2622"></a>ClockSystem</strong></span>, it can be also used as a standalone application outside of Gemoc studio.</p></div><p>Calling <span class="strong"><strong><a class="indexterm" name="d0e2630"></a>ClockSystem</strong></span> from Gemoc studio on the file generated by <span class="emphasis"><em>T2</em></span>(.clocksystem) generates exploration results including a LTS. To invoke ClockSystem right-click on the <span class="strong"><strong><a class="indexterm" name="d0e2639"></a>ClockSystem</strong></span> model (.clocksystem)&#8594;ClockSystem&#8594;Execute ClockSystem.</p><p>Generated files are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">.lts file stores labeled transition system (LTS) which represents all the possible configurations the system can reach.</li><li class="listitem">obp.lts file stores labeled transition system (LTS) in a format understandable by <a class="link" href="http://www.obpcdl.org/doku.php" target="_top">OBP</a>.</li><li class="listitem">.results extract global information about the size of the explored graph(number of states, transitions and time of exploration).</li><li class="listitem">full.gml is the representation of the LTS graph stored in a Graph Modelling Language (<a class="link" href="http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf" target="_top">GML</a>)  format providing a simple syntax to represent graph.</li><li class="listitem">fcr.gml is the representation of the LTS graph with the coincidences flatten for Fiacre stored in GML.</li><li class="listitem">.mtx stores the representation of the LTS graph as a <a class="link" href="http://math.nist.gov/MatrixMarket/formats.html" target="_top">Matrix Market</a> providing a simple and standardised way to exchange matrix data.</li></ul></div><p>The picture below illustrates an instance and its corresponding exploration graph <a class="xref" href="ch08s03.html#figure-instance-graph" title="Figure&nbsp;8.6.&nbsp;Exploration Graph for an Instance">Figure&nbsp;8.6, &#8220;Exploration Graph for an Instance&#8221;</a>.</p><div class="figure"><a name="figure-instance-graph"></a><div class="figure-contents"><div class="mediaobject"><img src="./images/exhaustive_exploration/instance_graph.png" width="400" alt="Exploration Graph for an Instance"></div></div><p class="title"><b>Figure&nbsp;8.6.&nbsp;Exploration Graph for an Instance</b></p></div><br class="figure-break"></div></div><div class="section" title="8.3.3.&nbsp;Defining Properties"><div class="titlepage"><div><div><h3 class="title"><a name="_defining_properties"></a>8.3.3.&nbsp;Defining Properties</h3></div></div></div><p>The properties are expressed using assertions or/and observer automata with appropriate variables and clocks of the model instance.  Several groups of properties are interesting to verify at different level in the Gemoc process.
Properties can be expressed on the model instance based on variables and clocks of one (or several) model element(s) and allows to check deadlocks, precedency between events, reachability etc&#8230;&#8203; The expression of the properties are model dependent so on each instance you must rewrite the properties.
However properties can also be related to representative instances which are based on a mapping between a generic abstract syntax, or a metamodel pattern and a mapped Mocc on this abstract syntax. In this approach we are looking for a reducing number of instance to verify and increase the generality of the verification approach.
A representative instance is a model that spreads a configuration that is structuraly relevant regarding the metamodel pattern.
On this representative model, we can verify properties tightly linked with the <span class="strong"><strong><a class="indexterm" name="d0e2693"></a>MoCCML</strong></span> semantics.</p><p>For instance the model <a class="xref" href="ch08s03.html#figure-instance-graph" title="Figure&nbsp;8.6.&nbsp;Exploration Graph for an Instance">Figure&nbsp;8.6, &#8220;Exploration Graph for an Instance&#8221;</a> can be considered as a representative instance of a <span class="emphasis"><em>Classifier-Relationship</em></span> metamodel pattern.
On it wish to apply a Mocc SDF semantics and therefore generic properties can be expressed as:
- If all the input ports of a <span class="emphasis"><em>Block</em></span> haven&#8217;t enought data to consume then the <span class="emphasis"><em>Block</em></span> canno&#8217;t execute.
- If the number of data of an output port is less than the <span class="emphasis"><em>Connector</em></span> capacity minus the current size of the <span class="emphasis"><em>Connector</em></span> then the <span class="emphasis"><em>Block</em></span> can execute.
- In any case, the current size of a <span class="emphasis"><em>Connector</em></span> canno&#8217;t exceed its capacity.</p><p>These properties are representatives of the Mocc and could be verified for every model. So we verify these properties on the representative model instance, to improve the trust on our pattern.</p><div class="section" title="8.3.3.1.&nbsp;Expressing Properties (CDL Formalization)"><div class="titlepage"><div><div><h4 class="title"><a name="_expressing_properties_cdl_formalization"></a>8.3.3.1.&nbsp;Expressing Properties (CDL Formalization)</h4></div></div></div><p>Properties have to be formalized for a checking tool. As <span class="strong"><strong><a class="indexterm" name="d0e2731"></a>ClockSystem</strong></span> provides a connector to <span class="emphasis"><em>OBP</em></span> model-checking infrastructure we present a <span class="emphasis"><em>CDL</em></span> formalization of the properties, which is also an <span class="emphasis"><em>OBP</em></span> compatible format. The <span class="emphasis"><em>CDL</em></span> formalism provides 3 distincts constructs for expressing safety and bounded-liveness properties predicates to express invariants over states, observers to express invariants over execution traces and property patterns, for simplifying the expression of complex properties.</p><p>Properties are described using CDL syntax and must be specified at instance level therefore the name of the processes or variable used in properties reflects the names and variables of instances within the verified model. CDL properties can be written in a simple text file with the extension .cdl.</p><p>For instance we impose our model to respect a SDF-like semantics and therefore we are interested in verifying properties that defines SDF:
- If all the input ports of a <span class="emphasis"><em>Block</em></span> haven&#8217;t enought data to consume then the <span class="emphasis"><em>Block</em></span> canno&#8217;t be executed.
- The current size of a <span class="emphasis"><em>Connector</em></span> canno&#8217;t exceed its capacity. An internal moc variable called <span class="emphasis"><em>current_size</em></span> increments or decrements respectively if a data is <span class="emphasis"><em>push</em></span> or <span class="emphasis"><em>pop</em></span> within the <span class="emphasis"><em>Connector</em></span>, and this variable must be always lower than the maximal capacity of the Connector.</p><p>In the listing <a class="xref" href="ch08s03.html#cdl_properties_example">???</a>  three properties are encoded in CDL code.</p><a name="cdl_properties_example"></a><pre class="screen">// Size of connector A to B never exceeds its capacity
predicate p2 is { {connectorAB}1 : currentsize &lt;= 4 }

// If Output channel is full the Block desnt execute
predicate p3 is { {connectorBA}1 : currentsize + {outport1}1 : rate &lt;= {connectorBA}1 : capacity }
property o1 is {
	start -- / p3 // -&gt; s1
	; s1 -- / / eB / -&gt; reject
	; s1 -- / not p3 / / -&gt; start
}

// Select the properties to be checked
cdl representativeInstance is {
	properties
	, o1
	assert p1
	; assert p2
	main is {skip}
}</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">The size of channels between A and B canno&#8217;t exceed the capacity of the connector. This is described with predicates <span class="emphasis"><em>p1</em></span> and <span class="emphasis"><em>p2</em></span> that check if the fifo size limit is reached.</li><li class="listitem">It is not possible to write in a <span class="emphasis"><em>Connector</em></span> if it is full. This is checked via the observer automata o1 for one <span class="emphasis"><em>Connector</em></span>. If the size of the <span class="emphasis"><em>Connector</em></span> plus the output rate exceed the size limit and if then <span class="emphasis"><em>Block</em></span> execute(eB) the observer o1 goes to reject state.</li></ul></div></div><div class="section" title="8.3.3.2.&nbsp;OBP example"><div class="titlepage"><div><div><h4 class="title"><a name="_obp_example"></a>8.3.3.2.&nbsp;OBP example</h4></div></div></div><p>The <span class="emphasis"><em>OBP</em></span> Observation Engine checks a set of CDL properties using reachability strategy (breath-first-search algorithm) on the graph induced by the parallel composition of the system, with its contexts.</p><p>In the context of Gemoc OBP <span class="emphasis"><em>OBP</em></span> requires two input files i.e the LTS generated from <span class="emphasis"><em>ClockSystem</em></span> and the CDL properties.
This operation has to be done manually and is not part of the Gemoc studio tooling since OBP is not integrated to the studio.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.2.&nbsp;Executing model with the Concurrent Engine&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="Guide.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;9.&nbsp;Coordinating Model Execution</td></tr></table></div></body></html>